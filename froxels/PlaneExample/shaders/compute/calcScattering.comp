#version 430

#define TEX_DIMS ivec3(160,90,64)
#define PI 3.1415926538

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

// Output texture
uniform writeonly image3D SCATTERING_UNIT;

// Input textures
uniform sampler3D HISTORY_UNIT;

// Camera props
uniform vec4 CAM_POS;
uniform mat4 INV_VIEW_MAT;
uniform mat4 INV_PROJ_MAT;
uniform mat4 PREV_PROJ_VIEW_MAT;
uniform float NEAR;
uniform float FAR;

uniform uint FRAME_COUNT;

// Directional light props
uniform vec4 DIRECT_LIGHT_DIR;
uniform vec4 DIRECT_LIGHT_COLOR;
uniform float DIRECT_LIGHT_INTENSITY;
uniform sampler2DShadow DIRECT_LIGHT_SHADOW_MAP;
uniform mat4 DIRECT_LIGHT_SPACE_MAT;

// Cube and sphere fog props
uniform vec3 CUBE_SCATTERING;
uniform float CUBE_ABSORPTION;
uniform float CUBE_DENSITY;
uniform float CUBE_ANISOTROPY;

uniform vec3 SPHERE_SCATTERING;
uniform float SPHERE_ABSORPTION;
uniform float SPHERE_DENSITY;
uniform float SPHERE_ANISOTROPY;

// Other props
uniform float AMBIENT_LIGHT_STRENGTH;
uniform int VOL_ACTIVE;

float jitter[32] = {
    0.375, 0.4375,
    0.625, 0.0625,
    0.875, 0.1875,
    0.125, 0.0625,
    0.375, 0.6875,
    0.875, 0.4375,
    0.625, 0.5625,
    0.375, 0.9375,
    0.625, 0.3125,
    0.125, 0.5625,
    0.125, 0.8125,
    0.375, 0.1875,
    0.875, 0.9375,
    0.875, 0.6875,
    0.125, 0.3125,
    0.625, 0.8125
    };

vec3 id_to_world_with_jitter(ivec3 id, float jitter, float n, float f, float depth_power, mat4 inv_vp);
vec3 id_to_world(ivec3 id, float n, float f, float depth_power, mat4 inv_vp);
vec3 world_to_uv(vec3 world_pos, float n, float f, float depth_power, mat4 vp);

vec2 exampleCubeSphere(vec4 worldPos, float cubeDensity, float sphereDensity);

//////////////////////////////////////////////////////////////////
//
//                     Auxiliary functions
//
//////////////////////////////////////////////////////////////////
float mean3(vec3 v) {
    return (v.x + v.y + v.z) / 3;
}

float camLightAngle(vec4 worldPos) {
    vec4 froxelCamDir = normalize(CAM_POS - worldPos);
    vec4 froxelLightDir = normalize(-DIRECT_LIGHT_DIR);

    return acos(dot(froxelLightDir, froxelCamDir));
}

float getJitter(ivec3 threadID) {
    uint idx = int(FRAME_COUNT + threadID.x * threadID.y * threadID.z) % 32;

    return (jitter[idx] - 0.5) * 0.999;
}

//////////////////////////////////////////////////////////////////
//
//                    Light shadow sampling
//
//////////////////////////////////////////////////////////////////
vec2 directLightLuminance(vec4 worldPos) {
    vec4 lightSpacePos = DIRECT_LIGHT_SPACE_MAT * worldPos;
    float shadow = textureProj(DIRECT_LIGHT_SHADOW_MAP, lightSpacePos);

    return vec2(shadow * (1 - AMBIENT_LIGHT_STRENGTH), AMBIENT_LIGHT_STRENGTH);
}

//////////////////////////////////////////////////////////////////
//
//       In-scattering and volumetric shadows calculation
//
//////////////////////////////////////////////////////////////////
float getDirectLightVolumetricTransmittance(vec4 worldPos) {
    float transmittance = 1.0;
    int ceiling = 500;

    vec4 curWorldPos = worldPos;
    vec4 stride = vec4(-DIRECT_LIGHT_DIR.xyz, 0.0) * ((ceiling - worldPos.y) / 16);
    float strideLen = length(stride);

    for (int i = 0; i < 16 && curWorldPos.y < ceiling; i++) {
        vec2 densities = exampleCubeSphere(curWorldPos, CUBE_DENSITY, SPHERE_DENSITY);
        vec3 scattering = CUBE_SCATTERING * densities.x + SPHERE_SCATTERING * densities.y;
        float absorption = CUBE_ABSORPTION * densities.x + SPHERE_ABSORPTION * densities.y;
        float extinction = mean3(scattering) + absorption;

        float stepTransmittance = exp(-extinction * strideLen);
        transmittance *= stepTransmittance;
        curWorldPos += stride;
    }

    return transmittance;
}

vec3 calcScattering(vec3 scattering, float phase, float inLight, vec4 lightColor, float intensity) {
    return scattering * intensity * phase * inLight * lightColor.rgb;
}

//////////////////////////////////////////////////////////////////
//
//                      Phase calculation
//
//////////////////////////////////////////////////////////////////
float henyeyGreenstein(vec4 worldPos, vec4 camPos, vec4 lightDir, float g) {
    vec4 pointCamDir = normalize(camPos - worldPos);
    vec4 pointLightDir = normalize(lightDir);

    float cosAngle = dot(pointCamDir, pointLightDir);
    float denom = 4 * PI * pow((1 + g * g - 2 * g * cosAngle), 3 / 2);
    return (1 - g * g) / denom;
}

float isotropicPhase() {
    return 1 / (4 * 3.14159);
}

void main() {
    if (VOL_ACTIVE == 1) {
        return;
    }

    ivec3 storeLoc = ivec3(gl_GlobalInvocationID);

    if (all(lessThan(storeLoc, TEX_DIMS))) {
        vec3 lScat = vec3(0);
        float extinction = 0.0;
        float isotropicPhase = isotropicPhase();

        float jit = getJitter(storeLoc);
        vec4 worldPos = vec4(id_to_world_with_jitter(storeLoc, jit, NEAR, FAR, 0.0, INV_VIEW_MAT * INV_PROJ_MAT), 1.0);
        vec2 densities = exampleCubeSphere(worldPos, CUBE_DENSITY, SPHERE_DENSITY);

        vec3 scattering = CUBE_SCATTERING * densities.x + SPHERE_SCATTERING * densities.y;
        float absorption = CUBE_ABSORPTION * densities.x + SPHERE_ABSORPTION * densities.y;
        extinction += mean3(scattering) + absorption;

        if (any(greaterThan(densities, vec2(0.00001)))) {
            vec2 luminances = directLightLuminance(worldPos) * getDirectLightVolumetricTransmittance(worldPos);
            float phaseCube = densities.x > 0.00001 ? henyeyGreenstein(worldPos, CAM_POS, DIRECT_LIGHT_DIR, CUBE_ANISOTROPY) : 0;
            float phaseSphere = densities.y > 0.00001 ? henyeyGreenstein(worldPos, CAM_POS, DIRECT_LIGHT_DIR, SPHERE_ANISOTROPY) : 0;
            float combinedPhase = (phaseCube + phaseSphere) / 2;


            lScat += calcScattering(scattering, isotropicPhase, luminances.y, DIRECT_LIGHT_COLOR, DIRECT_LIGHT_INTENSITY);
            lScat += calcScattering(scattering, combinedPhase, luminances.x, DIRECT_LIGHT_COLOR, DIRECT_LIGHT_INTENSITY);
        }
        vec4 scatExt = vec4(lScat, extinction);

        // TAA
        vec4 worldPosWithoutJitter = vec4(id_to_world(storeLoc, NEAR, FAR, 0.0, INV_VIEW_MAT * INV_PROJ_MAT), 1.0);
        vec3 hist_uv = world_to_uv(worldPosWithoutJitter.xyz, NEAR, FAR, 0.0, PREV_PROJ_VIEW_MAT);

        if (all(greaterThanEqual(hist_uv, vec3(0.0))) && all(lessThanEqual(hist_uv, vec3(1.0)))) {
            vec4 history = textureLod(HISTORY_UNIT, hist_uv, 0);
            scatExt = mix(history, scatExt, 0.05);
        }

        imageStore(SCATTERING_UNIT, storeLoc, scatExt);
    }
}
