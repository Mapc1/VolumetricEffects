#version 430

#define TEX_DIMS ivec3(160,90,128)
#define PI 3.1415926538

layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

// Output texture
uniform writeonly image3D SCATTERING_UNIT;

// Input textures
uniform sampler2DShadow SHADOW_MAP;

// To get the world position of the froxel
uniform mat4 INV_VIEW_MAT;
uniform mat4 INV_PROJ_MAT;
uniform float NEAR;
uniform float FAR;

// To get the angle for the phase function
uniform vec4 CAM_POS;
uniform vec4 LIGHT_DIR;

// To sample shadow map
uniform mat4 LIGHT_SPACE_MAT;

uniform vec4 LIGHT_COLOR;

// Variable params
uniform float ANISOTROPY;
uniform vec3 SCATTERING;
uniform float ABSORPTION;
uniform float DENSITY;
uniform float LIGHT_INTENSITY;
uniform float AMBIENT_LIGHT_STRENGTH;
uniform int NUM_SAMPLES_PER_VOXEL;
uniform int VOL_ACTIVE;


vec3 id_to_world_with_jitter(ivec3 id, float jitter, float n, float f, float depth_power, mat4 inv_vp);

float jitter[32] = {
    0.375, 0.4375,
    0.625, 0.0625,
    0.875, 0.1875,
    0.125, 0.0625,
    0.375, 0.6875,
    0.875, 0.4375,
    0.625, 0.5625,
    0.375, 0.9375,
    0.625, 0.3125,
    0.125, 0.5625,
    0.125, 0.8125,
    0.375, 0.1875,
    0.875, 0.9375,
    0.875, 0.6875,
    0.125, 0.3125,
    0.625, 0.8125
};


float camLightAngle(vec4 worldPos) {
    vec4 froxelCamDir = normalize(CAM_POS - worldPos);
    vec4 froxelLightDir = normalize(-LIGHT_DIR);

    return acos(dot(froxelLightDir, froxelCamDir));
}


float henyeyGreenstein(vec4 worldPos, float g) {
    vec4 froxelCamDir = normalize(CAM_POS - worldPos);
    vec4 froxelLightDir = normalize(LIGHT_DIR);

    float cosAngle = dot(froxelCamDir, froxelLightDir);
    float denom = 4*PI * pow((1+g*g - 2*g*cosAngle), 3/2);
    return (1-g*g) / denom;
}

float sampleShadowMap(vec4 worldPos) {
    vec4 projShadowCoord = LIGHT_SPACE_MAT * worldPos;
    return textureProj(SHADOW_MAP, projShadowCoord / projShadowCoord.w);
}

bool sdfCube(vec4 worldPos, vec4 center, float lengthX, float lengthY, float lengthZ) {
    float halfLenX = lengthX / 2;
    float halfLenY = lengthY / 2;
    float halfLenZ = lengthZ / 2;

    return worldPos.x <= halfLenX+center.x && worldPos.x >= -halfLenX+center.x &&
           worldPos.y <= halfLenY+center.y && worldPos.y >= -halfLenY+center.y &&
           worldPos.z <= halfLenZ+center.z && worldPos.z >= -halfLenZ+center.z;
}

bool sdfSphere(vec4 worldPos, vec4 center, float radius) {
    float dist = length(worldPos - center);

    return dist < radius;
}

bool homogeneousMedia() {
    return true;
}

bool sampleMedia(vec4 worldPos){
    return homogeneousMedia();//sdfCube(worldPos, vec4(0,500.0,0.0,1.0), 500.0, 800.0, 500.0) || sdfSphere(worldPos, vec4(0.0,2000.0,0.0,1.0), 500.0);
}

float shadowCalc(vec4 worldPos, float extinction) {
    return sampleShadowMap(worldPos);
}


float z_slice_thickness(int z)
{
    return exp(-float(TEX_DIMS.z - z - 1) / float(TEX_DIMS.z));
}


vec3 calcScattering(vec3 scattering, float phase, float inLight, vec4 lightColor, float intensity) {
    return scattering * intensity * phase * inLight * lightColor.rgb;
}


float mean3(vec3 v) {
    return (v.x + v.y + v.z) / 3;
}

void main() {
    if (VOL_ACTIVE == 1) {
        return;
    }

    ivec3 storeLoc = ivec3(gl_GlobalInvocationID);

    vec3 lScat = vec3(0);
    vec3  avgScattering = vec3(0);
    float avgAbsorption = 0;
    float avgExtinction = 0;
    float avgPhase = 0;
    float avgShadow = 0;

    for (int i = 0; i < NUM_SAMPLES_PER_VOXEL; i++) {
        vec4 worldPos = vec4(id_to_world_with_jitter(storeLoc, jitter[i], NEAR, FAR, 0.0, INV_VIEW_MAT * INV_PROJ_MAT), 1.0);
        float thickness = z_slice_thickness(storeLoc.z);
    
        float density = sampleMedia(worldPos) ? DENSITY : 0.0;
        avgScattering += SCATTERING * density;
        avgAbsorption += ABSORPTION * density;
    
        avgPhase  += henyeyGreenstein(worldPos, ANISOTROPY);
        avgShadow += sampleShadowMap(worldPos);
    }
    avgScattering /= NUM_SAMPLES_PER_VOXEL;
    avgAbsorption /= NUM_SAMPLES_PER_VOXEL;
    avgPhase /= NUM_SAMPLES_PER_VOXEL;
    avgShadow /= NUM_SAMPLES_PER_VOXEL;

    avgExtinction = mean3(avgScattering) + avgAbsorption;

    lScat = calcScattering(avgScattering, avgPhase, avgShadow, LIGHT_COLOR, LIGHT_INTENSITY);
    imageStore(SCATTERING_UNIT, storeLoc, vec4(lScat, avgExtinction));
}