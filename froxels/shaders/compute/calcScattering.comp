#version 430

#define TEX_DIMS ivec3(160,90,64)
#define PI 3.1415926538

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

// Output texture
uniform writeonly image3D SCATTERING_UNIT;

// Input textures
uniform sampler3D HISTORY_UNIT;
uniform sampler3D DENSITY_UNIT;

// Camera props
uniform vec4 CAM_POS;
uniform mat4 INV_VIEW_MAT;
uniform mat4 INV_PROJ_MAT;
uniform mat4 PREV_PROJ_VIEW_MAT;
uniform float NEAR;
uniform float FAR;

uniform uint FRAME_COUNT;

// Directional light props
uniform vec4 DIRECT_LIGHT_DIR;
uniform vec4 DIRECT_LIGHT_COLOR;
uniform float DIRECT_LIGHT_INTENSITY;
uniform bool DIRECT_LIGHT_ENABLED;
uniform sampler2DShadow DIRECT_LIGHT_SHADOW_MAP;
uniform mat4 DIRECT_LIGHT_SPACE_MAT;

// Point light shadow maps
uniform samplerCube POINT_LIGHT_1_SHADOW_MAP;
uniform samplerCube POINT_LIGHT_2_SHADOW_MAP;
uniform samplerCube POINT_LIGHT_3_SHADOW_MAP;
uniform samplerCube POINT_LIGHT_4_SHADOW_MAP;
uniform samplerCube POINT_LIGHT_5_SHADOW_MAP;
uniform samplerCube POINT_LIGHT_6_SHADOW_MAP;
uniform samplerCube POINT_LIGHT_7_SHADOW_MAP;
uniform samplerCube POINT_LIGHT_8_SHADOW_MAP;
uniform samplerCube POINT_LIGHT_9_SHADOW_MAP;
uniform samplerCube POINT_LIGHT_10_SHADOW_MAP;

// Fog props
uniform float ANISOTROPY;
uniform vec3 SCATTERING;
uniform float ABSORPTION;
uniform float DENSITY;

// Other props
uniform float AMBIENT_LIGHT_STRENGTH;
uniform int VOL_ACTIVE;
uniform int HOMOGENEOUS_MEDIA;

const int NUM_LIGHTS = 10;

// For density texture
const vec3 DENSITY_TEX_DIMS = vec3(256,256,256);
const vec4 MIN = vec4(-3000,-3000,-3000,1.0);
const vec4 MAX = vec4(3000,3000,3000,1.0);

// Density texture stride
vec3 WIND = vec3(1.0,0.0,0.0);
float WIND_SPEED = 0.0002;

layout(std430, binding = 1) buffer Buff1 {
    vec4 positions[NUM_LIGHTS];
};
layout(std430, binding = 2) buffer Buff2 {
    vec4 colors[NUM_LIGHTS];
};
layout(std430, binding = 3) buffer Buff3 {
    float intensities[NUM_LIGHTS];
};
layout(std430, binding = 4) buffer Buff4 {
    float maxRanges[NUM_LIGHTS];
};
layout(std430, binding = 5) buffer Buff5 {
    bool enableds[NUM_LIGHTS];
};

float jitter[32] = {
    0.375, 0.4375,
    0.625, 0.0625,
    0.875, 0.1875,
    0.125, 0.0625,
    0.375, 0.6875,
    0.875, 0.4375,
    0.625, 0.5625,
    0.375, 0.9375,
    0.625, 0.3125,
    0.125, 0.5625,
    0.125, 0.8125,
    0.375, 0.1875,
    0.875, 0.9375,
    0.875, 0.6875,
    0.125, 0.3125,
    0.625, 0.8125
};

vec3 id_to_world_with_jitter(ivec3 id, float jitter, float n, float f, float depth_power, mat4 inv_vp);
vec3 id_to_world(ivec3 id, float n, float f, float depth_power, mat4 inv_vp);
vec3 world_to_uv(vec3 world_pos, float n, float f, float depth_power, mat4 vp);

float sampleMedia(vec4 worldPos, bool isHomogeneousMedia, vec4 minPos, vec4 maxPos, vec3 windOffset, sampler3D densityTexture);

//////////////////////////////////////////////////////////////////
//
//                     Auxiliary functions
//
//////////////////////////////////////////////////////////////////
float mean3(vec3 v) {
    return (v.x + v.y + v.z) / 3;
}

float camLightAngle(vec4 worldPos) {
    vec4 froxelCamDir = normalize(CAM_POS - worldPos);
    vec4 froxelLightDir = normalize(-DIRECT_LIGHT_DIR);

    return acos(dot(froxelLightDir, froxelCamDir));
}

float getJitter(ivec3 threadID) {
    uint idx = int(FRAME_COUNT + threadID.x * threadID.y * threadID.z) % 32;

    return (jitter[idx] - 0.5) * 0.999;
}


//////////////////////////////////////////////////////////////////
//
//                    Light shadow sampling
//
//////////////////////////////////////////////////////////////////
vec2 directLightLuminance(vec4 worldPos) {
    vec4 lightSpacePos = DIRECT_LIGHT_SPACE_MAT * worldPos;
    float shadow = textureProj(DIRECT_LIGHT_SHADOW_MAP, lightSpacePos);

    return vec2(shadow * (1-AMBIENT_LIGHT_STRENGTH), AMBIENT_LIGHT_STRENGTH);
}

float sampleCorrectShadowMap(int lightID, vec3 rayDir){
    switch (lightID) {
        case 0:
            return texture(POINT_LIGHT_1_SHADOW_MAP, rayDir).r;
        case 1:
            return texture(POINT_LIGHT_2_SHADOW_MAP, rayDir).r;
        case 2:
            return texture(POINT_LIGHT_3_SHADOW_MAP, rayDir).r;
        case 3:
            return texture(POINT_LIGHT_4_SHADOW_MAP, rayDir).r;
        case 4:
            return texture(POINT_LIGHT_5_SHADOW_MAP, rayDir).r;
        case 5:
            return texture(POINT_LIGHT_6_SHADOW_MAP, rayDir).r;
        case 6:
            return texture(POINT_LIGHT_7_SHADOW_MAP, rayDir).r;
        case 7:
            return texture(POINT_LIGHT_8_SHADOW_MAP, rayDir).r;
        case 8:
            return texture(POINT_LIGHT_9_SHADOW_MAP, rayDir).r;
        case 9:
            return texture(POINT_LIGHT_10_SHADOW_MAP, rayDir).r;
        default:
            return 0.0;
    }
}

vec2 pointLightLuminance(vec4 worldPos, vec4 lightPos, float maxRange, int lightID) {
    vec3 fragLightDir = (worldPos - lightPos).xyz;
    float currentDepth = length(fragLightDir);

    float closestDepth = sampleCorrectShadowMap(lightID, fragLightDir);
    closestDepth *= FAR;

    float bias = 0.05;
    float shadow = currentDepth - bias <= closestDepth ? 1.0 : 0.0;
    float attenuation = max(0.0, (pow(maxRange, (maxRange-currentDepth)/maxRange)) / maxRange);

    return vec2(shadow * (1-AMBIENT_LIGHT_STRENGTH), AMBIENT_LIGHT_STRENGTH) * attenuation;
}


//////////////////////////////////////////////////////////////////
//
//       In-scattering and volumetric shadows calculation
//
//////////////////////////////////////////////////////////////////
float getDirectLightVolumetricTransmittance(vec4 worldPos, vec4 minPos, vec4 maxPos, vec3 windOffset) {
    float transmittance = 1.0;
    vec4 curWorldPos = worldPos;
    vec4 stride = vec4(-DIRECT_LIGHT_DIR.xyz,0.0) * ((MAX.y-worldPos.y)/16);
    float strideLen = length(stride);

    for (int i = 0; i < 16 && curWorldPos.y < MAX.y; i++) {
        float density = sampleMedia(curWorldPos, HOMOGENEOUS_MEDIA == 0, minPos, maxPos, windOffset, DENSITY_UNIT) * DENSITY;
        vec3 scattering = SCATTERING * density;
        float absorption = ABSORPTION * density;
        float extinction = mean3(scattering) + absorption;
        float stepTransmittance = exp(-extinction*strideLen);
        transmittance *= stepTransmittance;
        curWorldPos += stride;
    }

    return transmittance;
}

float getPointLightVolumetricTransmittance(vec4 worldPos, vec4 lightPos, vec4 minPos, vec4 maxPos, vec3 windOffset) {
    float transmittance = 1.0;
    vec4 curWorldPos = worldPos;
    vec4 strideDir = lightPos-worldPos;
    float strideLen = length(strideDir)/16;
    vec4 stride = strideDir * strideLen;

    for (int i = 0; i < 16; i++) {
        float density = sampleMedia(curWorldPos, HOMOGENEOUS_MEDIA == 0, minPos, maxPos, windOffset, DENSITY_UNIT) * DENSITY;
        vec3 scattering = SCATTERING * density;
        float absorption = ABSORPTION * density;
        float extinction = mean3(scattering) + absorption;
        float stepTransmittance = exp(-extinction*strideLen);
        transmittance *= stepTransmittance;
        curWorldPos += stride;
    }

    return transmittance;
}

vec3 calcScattering(vec3 scattering, float phase, float inLight, vec4 lightColor, float intensity) {
    return scattering * intensity * phase * inLight * lightColor.rgb;
}


//////////////////////////////////////////////////////////////////
//
//                      Phase calculation
//
//////////////////////////////////////////////////////////////////
float henyeyGreenstein(vec4 worldPos, vec4 camPos, vec4 lightDir, float g) {
    vec4 pointCamDir = normalize(camPos - worldPos);
    vec4 pointLightDir = normalize(lightDir);

    float cosAngle = dot(pointCamDir, pointLightDir);
    float denom = 4*PI * pow((1+g*g - 2*g*cosAngle), 3/2);
    return (1-g*g) / denom;
}

float isotropicPhase() {
    return 1/(4*3.14159);
}


void main() {
    if (VOL_ACTIVE == 1) {
        return;
    }

    ivec3 storeLoc = ivec3(gl_GlobalInvocationID);

    if (all(lessThan(storeLoc, TEX_DIMS))) {
        vec3 lScat = vec3(0);
        float extinction = 0.0;
        float isotropicPhase = isotropicPhase();
    
        float jit = getJitter(storeLoc);
        vec4 worldPos = vec4(id_to_world_with_jitter(storeLoc, jit, NEAR, FAR, 0.0, INV_VIEW_MAT * INV_PROJ_MAT), 1.0);
        vec3 windOffset = FRAME_COUNT * WIND * WIND_SPEED;
        float density = sampleMedia(worldPos, HOMOGENEOUS_MEDIA == 0, MIN, MAX, windOffset, DENSITY_UNIT) * DENSITY;
        vec3 scattering = SCATTERING * density;
        float absorption = ABSORPTION * density;
        extinction += mean3(scattering) + absorption;

        if (density > 0.00001) {
            if (DIRECT_LIGHT_ENABLED) {
                vec2 luminances = directLightLuminance(worldPos) * getDirectLightVolumetricTransmittance(worldPos, MIN, MAX, windOffset);// * directLightLuminance(worldPos);
                float phase = henyeyGreenstein(worldPos, CAM_POS, DIRECT_LIGHT_DIR, ANISOTROPY);

                lScat += calcScattering(scattering, isotropicPhase, luminances.y, DIRECT_LIGHT_COLOR, DIRECT_LIGHT_INTENSITY);  
                lScat += calcScattering(scattering, phase, luminances.x, DIRECT_LIGHT_COLOR, DIRECT_LIGHT_INTENSITY);  
            }

            for (int j = 0; j < NUM_LIGHTS; j++) {
                vec4 lightPos = positions[j];
                vec4 lightColor = colors[j];
                float lightIntensity = intensities[j];
                float maxRange = maxRanges[j];
                bool enabled = enableds[j];

                if (enabled) {
                    vec4 worldLightDir = worldPos - lightPos;
                    vec2 luminances = pointLightLuminance(worldPos, lightPos, maxRange, j) * getPointLightVolumetricTransmittance(worldPos, lightPos, MIN, MAX, windOffset);
                    float phase = henyeyGreenstein(worldPos, CAM_POS, worldLightDir, ANISOTROPY);

                    lScat += calcScattering(scattering, isotropicPhase, luminances.y, lightColor, lightIntensity);
                    lScat += calcScattering(scattering, phase, luminances.x, lightColor, lightIntensity);
                }
            }
        }
        vec4 scatExt = vec4(lScat, extinction);

        // TAA
        vec4 worldPosWithoutJitter = vec4(id_to_world(storeLoc, NEAR, FAR, 0.0, INV_VIEW_MAT * INV_PROJ_MAT), 1.0);
        vec3 hist_uv = world_to_uv(worldPosWithoutJitter.xyz, NEAR, FAR, 0.0, PREV_PROJ_VIEW_MAT);

        if (all(greaterThanEqual(hist_uv, vec3(0.0))) && all(lessThanEqual(hist_uv, vec3(1.0)))) {
            vec4 history = textureLod(HISTORY_UNIT, hist_uv, 0);
            scatExt = mix(history, scatExt, 0.05);
        }

        imageStore(SCATTERING_UNIT, storeLoc, scatExt);
    }
}
